package twistlock

import (
	"log"
	"time"

	"github.com/Hivebrite/twistlock-go/sdk"
	"github.com/Hivebrite/twistlock-go/sdk/vulnerabilities"
	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/helper/validation"
	"github.com/spf13/cast"
)

func resourceVulnerabilityPolicies() *schema.Resource {
	return &schema.Resource{
		Create: createVulnerabilityPolicies,
		Read:   readVulnerabilityPolicies,
		Update: createVulnerabilityPolicies,
		Delete: deleteVulnerabilityPolicies,

		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},

		Schema: map[string]*schema.Schema{
			"policy_type": {
				Computed:    true,
				Type:        schema.TypeString,
				Description: "",
			},
			"rules": {
				Type:     schema.TypeList,
				Required: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Required:    true,
							Type:        schema.TypeString,
							Description: "",
						},
						"resources": {
							Type:        schema.TypeSet,
							Required:    true,
							Description: "",
							MinItems:    1,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"hosts": {
										Required:    true,
										Type:        schema.TypeList,
										Description: "",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"images": {
										Required:    true,
										Type:        schema.TypeList,
										Description: "",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"labels": {
										Required:    true,
										Type:        schema.TypeList,
										Description: "",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"containers": {
										Required:    true,
										Type:        schema.TypeList,
										Description: "",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"namespaces": {
										Required:    true,
										Type:        schema.TypeList,
										Description: "",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"account_ids": {
										Required:    true,
										Type:        schema.TypeList,
										Description: "",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"clusters": {
										Required:    true,
										Type:        schema.TypeList,
										Description: "",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"block_msg": {
							Computed:    true,
							Optional:    true,
							Type:        schema.TypeString,
							Description: "",
						},
						"verbose": {
							Computed:    true,
							Optional:    true,
							Type:        schema.TypeBool,
							Description: "",
						},
						"grace_days": {
							Computed: true,
							Optional: true,
							Type:     schema.TypeInt,
						},
						"alert_threshold": {
							Required:    true,
							Type:        schema.TypeSet,
							Description: "Policy to alert",
							MinItems:    1,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"disabled": {
										Type:     schema.TypeBool,
										Required: true,
									},
									"value": {
										Type:     schema.TypeString,
										Required: true,
										ValidateFunc: validation.StringInSlice(
											[]string{
												vulnerabilities.Disable,
												vulnerabilities.Low,
												vulnerabilities.Medium,
												vulnerabilities.High,
												vulnerabilities.Critical,
											},
											false,
										),
									},
								},
							},
						},
						"block_threshold": {
							Required:    true,
							Type:        schema.TypeSet,
							Description: "Policy to block",
							MinItems:    1,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"enabled": {
										Type:     schema.TypeBool,
										Required: true,
									},
									"value": {
										Type:     schema.TypeString,
										Required: true,
										ValidateFunc: validation.StringInSlice(
											[]string{
												vulnerabilities.Disable,
												vulnerabilities.Low,
												vulnerabilities.Medium,
												vulnerabilities.High,
												vulnerabilities.Critical,
											},
											false,
										),
									},
								},
							},
						},
						"cve_rules": {
							Optional:    true,
							Computed:    true,
							Type:        schema.TypeSet,
							Description: "CVE Exception",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"effect": {
										Type:     schema.TypeString,
										Required: true,
										ValidateFunc: validation.StringInSlice(
											[]string{
												vulnerabilities.EffectAlert,
												vulnerabilities.EffectBlock,
												vulnerabilities.EffectIgnore,
											}, false),
									},
									"description": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"id": {
										Type:     schema.TypeString,
										Required: true,
									},
									"expiration": {
										Optional: true,
										Type:     schema.TypeSet,
										MinItems: 1,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"date": {
													Optional: true,
													Type:     schema.TypeString,
												},
												"enabled": {
													Required: true,
													Type:     schema.TypeBool,
												},
											},
										},
									},
								},
							},
						},
						"tags": {
							Optional:    true,
							Computed:    true,
							Type:        schema.TypeSet,
							Description: "CVE Exception",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"effect": {
										Type:     schema.TypeString,
										Required: true,
										ValidateFunc: validation.StringInSlice(
											[]string{
												vulnerabilities.EffectAlert,
												vulnerabilities.EffectBlock,
												vulnerabilities.EffectIgnore,
											}, false),
									},
									"description": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"name": {
										Type:     schema.TypeString,
										Required: true,
									},
									"expiration": {
										Optional: true,
										Type:     schema.TypeSet,
										MinItems: 1,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"date": {
													Optional: true,
													Type:     schema.TypeString,
												},
												"enabled": {
													Required: true,
													Type:     schema.TypeBool,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func parseVulnerabilityPolicies(d *schema.ResourceData) *vulnerabilities.Policies {
	policies := vulnerabilities.Policies{
		PolicyType: "containerVulnerability",
		ID:         "containerVulnerability",
	}

	rules := d.Get("rules").([]interface{})

	for _, i := range rules {
		rule := i.(map[string]interface{})
		resources := rule["resources"].(*schema.Set).List()[0].(map[string]interface{})
		blockThreshold := rule["block_threshold"].(*schema.Set).List()[0].(map[string]interface{})
		alertThreshold := rule["alert_threshold"].(*schema.Set).List()[0].(map[string]interface{})
		tags := rule["tags"].(*schema.Set).List()
		cveRules := rule["cve_rules"].(*schema.Set).List()

		ruleObject := vulnerabilities.Rules{
			Name: rule["name"].(string),
			Resources: vulnerabilities.Resources{
				Hosts:      cast.ToStringSlice(resources["hosts"]),
				Images:     cast.ToStringSlice(resources["images"]),
				Labels:     cast.ToStringSlice(resources["labels"]),
				Containers: cast.ToStringSlice(resources["containers"]),
				Namespaces: cast.ToStringSlice(resources["namespaces"]),
				AccountIDs: cast.ToStringSlice(resources["account_ids"]),
				Clusters:   cast.ToStringSlice(resources["clusters"]),
			},
			BlockMsg: rule["block_msg"].(string),
			Verbose:  rule["verbose"].(bool),
			AlertThreshold: vulnerabilities.AlertThreshold{
				Disabled: alertThreshold["disabled"].(bool),
				Value:    vulnerabilities.AlertingLevelToInt(alertThreshold["value"].(string)),
			},
			BlockThreshold: vulnerabilities.BlockThreshold{
				Enabled: blockThreshold["enabled"].(bool),
				Value:   vulnerabilities.AlertingLevelToInt(alertThreshold["value"].(string)),
			},
		}

		for _, j := range cveRules {
			cveRule := j.(map[string]interface{})
			expiration := fetchOptionalMapFromSetParam(cveRule, "expiration")

			ruleObject.CveRules = append(
				ruleObject.CveRules,
				vulnerabilities.CveRules{
					Effect:      cveRule["effect"].(string),
					Description: cveRule["description"].(string),
					ID:          cveRule["id"].(string),
					Expiration: vulnerabilities.Expiration{
						Enabled: func() bool {
							if expiration["enabled"] == nil {
								return false
							}

							return expiration["enabled"].(bool)
						}(),
						Date: func() time.Time {
							var expirationDate time.Time

							if expiration["date"] != nil && expiration["enabled"] == true {
								layout := "2006-01-02T15:04:05.999Z00:00"
								expirationDate, _ = time.Parse(layout, expiration["date"].(string))
							}
							return expirationDate
						}(),
					},
				},
			)
		}

		for _, j := range tags {
			tag := j.(map[string]interface{})
			expiration := fetchOptionalMapFromSetParam(tag, "expiration")

			ruleObject.Tags = append(
				ruleObject.Tags,
				vulnerabilities.Tags{
					Effect:      tag["effect"].(string),
					Description: tag["description"].(string),
					Name:        tag["name"].(string),
					Expiration: vulnerabilities.Expiration{
						Enabled: func() bool {
							if expiration["enabled"] == nil {
								return false
							}

							return expiration["enabled"].(bool)
						}(),
						Date: func() time.Time {
							var expirationDate time.Time

							if expiration["date"] != nil && expiration["enabled"] == true {
								layout := "2006-01-02T15:04:05.999999999Z07:00"
								expirationDate, _ = time.Parse(layout, expiration["date"].(string))
							}
							return expirationDate
						}(),
					},
				},
			)
		}

		policies.Rules = append(
			policies.Rules,
			ruleObject,
		)
	}

	return &policies
}

func saveVulnerabilityPolicies(d *schema.ResourceData, policiesObject *vulnerabilities.Policies) error {
	rules := make([]interface{}, 0, len(policiesObject.Rules))

	for _, i := range policiesObject.Rules {

		var tags []map[string]interface{}

		for _, tag := range i.Tags {
			tags = append(tags, map[string]interface{}{
				"effect":      tag.Effect,
				"name":        tag.Name,
				"description": tag.Description,
				"expiration": []map[string]interface{}{
					{
						"enabled": tag.Expiration.Enabled,
						"date":    tag.Expiration.Date.Format("2006-01-02T15:04:05.999999999Z07:00"),
					},
				},
			})
		}

		var cveRules []map[string]interface{}

		for _, cveRule := range i.CveRules {
			cveRules = append(cveRules, map[string]interface{}{
				"effect":      cveRule.Effect,
				"id":          cveRule.ID,
				"description": cveRule.Description,
				"expiration": []map[string]interface{}{
					{
						"enabled": cveRule.Expiration.Enabled,
						"date":    cveRule.Expiration.Date.Format("2006-01-02T15:04:05.999999999Z07:00"),
					},
				},
			})
		}

		rules = append(
			rules,
			map[string]interface{}{
				"name": i.Name,
				"resources": []map[string]interface{}{
					{
						"hosts":       i.Resources.Hosts,
						"images":      i.Resources.Images,
						"labels":      i.Resources.Labels,
						"containers":  i.Resources.Containers,
						"namespaces":  i.Resources.Namespaces,
						"account_ids": i.Resources.AccountIDs,
						"clusters":    i.Resources.Clusters,
					},
				},
				"block_msg": i.BlockMsg,
				"verbose":   i.Verbose,
				"alert_threshold": []map[string]interface{}{
					{
						"disabled": i.AlertThreshold.Disabled,
						"value":    vulnerabilities.AlertingIntToLevel(i.AlertThreshold.Value),
					},
				},
				"block_threshold": []map[string]interface{}{
					{
						"enabled": i.BlockThreshold.Enabled,
						"value":   vulnerabilities.AlertingIntToLevel(i.BlockThreshold.Value),
					},
				},
				"cve_rules":  cveRules,
				"tags":       tags,
				"grace_days": i.GraceDays,
			},
		)
	}

	d.SetId("containerVulnerability")

	err := d.Set("rules", rules)
	if err != nil {
		log.Printf("[ERROR] rules caused by: %s", err)
		return err
	}

	err = d.Set("policy_type", policiesObject.PolicyType)
	if err != nil {
		log.Printf("[ERROR] policy_type caused by: %s", err)
		return err
	}
	return nil
}

func createVulnerabilityPolicies(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*sdk.Client)
	err := vulnerabilities.SetPolicies(*client, parseVulnerabilityPolicies(d))
	if err != nil {
		return err
	}

	return readVulnerabilityPolicies(d, meta)
}

func readVulnerabilityPolicies(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*sdk.Client)
	policies, err := vulnerabilities.GetPolicies(*client)
	if err != nil {
		return err
	}

	return saveVulnerabilityPolicies(d, policies)
}

func deleteVulnerabilityPolicies(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*sdk.Client)
	err := vulnerabilities.SetPolicies(*client, &vulnerabilities.Policies{})
	if err != nil {
		return err
	}

	return nil
}
